## Part 1. Установка ОС

__cat /etc/issue__ # узнать версию Ubuntu


## Part 2. Создание пользователя
* __useradd -m user1__ # добавить нового пользователя
* __cat /etc/passwd__ # просмотреть, что пользователь добавлен
* __sudo passwd user1__ # установить пароль для user1
* __su user1__ # сменить пользователя на user1
* __exit__ # выйти из пользователя
* __sudo usermod -aG adm user1__ # добавить user1 в группу администратора, так он может просматривать файлы в /var/log
* __ls -l /var/log__ # проверка прав в папке /var/log
* __sudo userdel -r user1__ # удалить пользователя
* __hostnamectl__ # посмотреть информацию о хосте, hostname - и есть машина или сервер.

## Part 3. Настройка сети ОС
Для изменения имени сервера нужно изменить его в 2х файлах:

>sudo nano /etc/hosts
sudo nano /etc/hostname

__sudo cp /etc/localtime /etc/localtime.bak__ # создать резервную копию текущего часового пояса

__sudo ln -sf /usr/share/zoneinfo/Europe/Moscow /etc/localtime__ # меняет время в Linux на указанный пояс Europe/Moscow

__ls usr/share/zoneinfo__ # посмотреть все часовые пояса

__date__ # проверить свой часовой пояс

внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw - gateway - роутер).

__ifconfig__ # выведет названия сетевых интерфейсов enp0s3 и lo, а также ip, subnetmask
или
__ip addr__

интерфейс lo (loopback - локальная петля) - 127.0.0.1
нужен для того, чтобы компьютер даже при отсутствии сетевых интерфейсов мог обращаться к самому себе по IP 127.0.0.1
>route # посмотреть информацию по gateway роутера

#### Есть 3 вида ip:
1. lo - localhost - всегда 127.0.0.1 (выводится под интерфейсом lo в командах ip addr, ifconfig, ip -br a)
2. ip в локальной сети (те, что создает роутер - выводится под интерфейсом enp* или eth* в командах ip addr, ifconfig, ip -br a) 
3. внешний ip - ip роутера, через который происходит выход в интернет - также называется gateway
(можно ввести в браузере сайт https://ifconfig.me/, чтобы узнать этот ip, либо в терминале - curl ifconfig.me или curl ident.me)

#### DHCP (Dynamic Host Configuration Protocol)
Протокол DHCP является клиент-серверным, то есть в его работе участвуют клиент DHCP и сервер DHCP.
Передача данных производится при помощи протокола UDP. По умолчанию запросы от клиента делаются к серверу на порт 67,
сервер в свою очередь отвечает клиенту на порт 68, выдавая адрес IP и другую необходимую информацию, такую, как сетевую маску,
маршрутизатор и серверы DNS.

DHCP (англ. Dynamic Host Configuration Protocol — протокол динамической настройки узла) — прикладной протокол,
позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP.
Данный протокол работает по модели «клиент-сервер». Для автоматической конфигурации компьютер-клиент на этапе конфигурации сетевого устройства
обращается к так называемому серверу DHCP и получает от него нужные параметры.
Сетевой администратор может задать диапазон адресов, распределяемых сервером среди компьютеров.
Это позволяет избежать ручной настройки компьютеров сети и уменьшает количество ошибок.
Протокол DHCP используется в большинстве сетей TCP/IP.

>sudo nano /etc/netplan/00-installer-config.yaml # внесение статичных настроек ip, gw, dns (обязательно с соблюдением пробелов)

dhcp4 - если оставить true, то ip-адреса будут выдаваться автоматически

До того, как переписать .yaml-файл, вводим команду __ip route__, смотри дефолтный ip (10.0.2.2)
Далее статичный ip-адрес для машины нужно будет прописать в этой же подсети (в примере ниже 10.0.2.4/24)
This is the network config written by 'subiquitu'
```
network:
  version: 2
  ethernets:
    enp0s3:
      addresses: [10.0.2.4/24]
      nameservers:
        addresses: [1.1.1.1, 8.8.8.8]
      routes:
       - to: default
         via: 10.0.2.2
       dhcp4: false
```
__netplan --debug generate__
Далее сохранить эти настройки - либо sudo netplan apply,
лобо перезапустить sudo reboot now
и проверить через ping yandex.com, есть ли подключение к сети

## Part 4. Обновление ОС
__sudo apt update__ # вычисляет, сколько пакетов может быть обновлено
__sudo apt full-upgrade__ # установка всех обновлений
__sudo do-release-upgrade__ # обновление системы до новой версии (если она есть)

## Part 5. Использование команды sudo
sudo позволяет выполнять команды от имени root
__sudo su__ # зайти под root-ом, чтобы не нужно было в командах прописывать sudo, но тут все же напишу с ними

##### Для изменения имени сервера, надо изменить это имя в 2х файлах:
    /etc/hosts
    /etc/hostname

__sudo usermod -aG adm,sudo user1__ # добавляем user1 в группу adm и sudo

__ls -l /etc/hosts__ # проверить права в файле
__ls -l /etc/hostname__ # проверить права в файле

__sudo chmod g+w /etc/hosts__ # дать права на запись для группы adm
__sudo chmod g+w /etc/hostname__ # дать права на запись для группы adm

__sudo nano /etc/hosts__ # изменить имя сервера
__sudo nano /etc/hostname__ # изменить имя сервера

__sudo reboot now__ # перезагрузка, после этого имя сервера изменилось

## Part 6. Установка и настройка службы времени
__timedatectl show__ # команда выдает информацию о настройках времени

## Part 7. Установка и использование текстовых редакторов
>sudo apt install joe # установка редактора joe
sudo apt install mc # установка редактора mcedit
sudo apt install vim # установка редактора vim

_joe_: Ctrl+K - сохранить, а затем клавишу Q - для выхода

_mcedit_: Ecs, далее в меню выбрать сохранить или нет

_vim_: i - перейти в режим печати, Esc - выйти из режима печати, :wq - выйти с сохранением изменений, :q! - выйти без сохранения изменений

```
__grep user ./*__ - поиск слова user в текущей дериктории, на выводе строки, содержащие данное слово, из всех файлов

__grep user ./* | sed 's/user/friend/g'__ - в выводе заменит слово user на слово friend, при этом файлы НЕ изменятся

__grep user ./* | sed 's/user/friend/gw ./*'__ - в выводе заменит слово user на слово friend, при этом файлы изменятся
```

## Part 8. Установка и базовая настройка сервиса SSHD
```
sudo apt-get install openssh-server # установить ssh
sudo systemctl enable sshd # добавить в автозагрузку, чтобы служба запускалась автоматически
sudo systemctl disable sshd # удалить из автозагрузки
```

Если после удаления из автозагрузки снова попытаться добавить командой:
__sudo systemctl enable sshd__
выдаст ошибку Unit file sshd.service does not exist
поэтому надо обратиться по имени:
__sudo systemctl enable ssh__
после этого можно по команде ssh подключаться к удаленному серверу:
>ssh 127.0.0.1 или ssh -l user1 127.0.0.1 или ssh user1@127.0.0.1

>exit для прекращения сеанса

__service ssh status__ # проверить активен ли сервис и слушает ли порт 22
__service ssh start__ # сделать сервис активным

####Изменение порта SSH:

>sudo nano /etc/ssh/sshd_config

в файле нужно раскомментировать строку #Port 22 и заменить порт на другой, сохранить файл
в консоли перезапустить cbcntve: 

>systemctl restart sshd

проверяем статус:
>service sshd status

>netstat -tulpn # проверяет статус портов на прием и передачу, то есть порт (код, который ранее внесли) должен быть в 2х строках

>sudo ufw status # проверяем статус firewall (если inactive, то команда sudo ufw enable)

>sudo ufw allow 2022 # открываем доступ по порту 2022 (2022 - это пример, вносится тот же код, на который меняли порт 22)

после этого порты появятся в статусе (sudo ufw status)
перезапустим firewall: __ufw reload__
>netstat -tan

## Part 9. Установка и использование утилит top, htop
>top # диспетчер задач
пробел - обновить список процессов

первая строка показывает то же самое, что выводит команда uptime

```
us - количество авторизованных пользователей

load average - общая загрузка системы (за 1, 5 и 15 минут)
Если 1 процессор, то максимальное значение 1 (т.е. 100%), если 4 процессора, то максимальное значение 4 (т.е. 400%)

tasks - общее количество процессов

%CPU(s) - загрузку cpu (сколько процессоров загружено пользователем - us, сколько системой - sy)

MiB Mem - загрузку памяти
```
```
d - чтобы ввести задержку обновления

NI (Nice) - показатель, отвечающий за приоритетность процесса (19 - самый низкий приоритет, -20 - высокий)

PR - приоритет (0 - самый приоритетный)

r - чтобы изменить показатель nice, а соответственно и приоритет
После нажатия вводим PID процесса для изменения > Enter > число, на которое хотим изменить
Приоритет меняется автоматически

k (kill) - убить процесс, вводим PID процесса (если ввести 9, то убивает без ожидания завершения процесса, если 15, то ожидает завершения процесса)

shift + p # сортировка по колонке cpu (загрузка процессора)
shift + m # сортировка по колонке mem (загрузка памяти)
```

>htop #

```
выбрать, по чему сортировать shift + < и далее клавишами вверх-вниз и выбираем
t # отразить в виде дерева колонку Command
/текст # найти процесс по тексту (ищет в колонке Command)
\текст # отфильтровать по тексту (в колонке Command)
u > выбор из списка # фильтр по пользователю

пробел - выделяет строку (несколько строк) желтым и с ними можно произвести какое-то действие
U (большая с Shift) - для отмены выделения
F2 (с fn) - настройки
```
__cat /proc/sys/vm/swappiness__ # SWAP показывает при каком проценте загрузки системы начинается запись в файл подкачки
(если команда выводит 60, то уже при 40% заполненности оперативной памяти должна начаться запись в файл/раздел подкачки)

Чтобы поправить это значение, надо изменить/создать конфигурационный файл:
__/etc/sysctl.conf__ - сюда можно внести строку: vm.swappiness=80 (или другое число), либо создать новый файл с расширением .conf

после этого надо перезагрузить систему
если нет возможности перезагрузки, можно до конца текущей сессии задать значение swappiness:
__sudo sysctl vm.swappiness=80__

__cat /proc/meminfo__ # выводит информацию о памяти, в т.ч. о кэше
(при достижении загрузки операционной памяти, достаточной для начала подкачки в SWAP, это может происходить не сразу.
Сначала данные пойдут в кэш и только потом при достижении каких-то параметров в SWAP)

## Part 10. Использование утилиты fdisk
__sudo fdisk -l__ # по данной команде интересна информация в конце (Device) о дисках и partitions, а также типе (например, может быть SWAP)
__lsblk__ # информация о дисках деревом


Sata disk:
```
sda - a - это 1й диск
  sda1 - partition 1
  sda2 - partition 2
sdb - b - это 2й диск (если есть)
sdc - c - это 3й диск (если есть)
```

## Part 11. Использование утилиты df (disk free)
Узнать информацияю о разделах диска (/ - корневой раздел):
>df
df -Th

Типы файловых систем (можно найти в команде df -Th):
* ext2/3/4 (extended filesystem):
    позволяет снизить уровень фрагментации файловой системы: система хранит информацию не только о местоположении свободных блоков,
    но и о количестве свободных блоков, расположенных друг за другом, таким образом, при выделении места система находит такой фрагмент,
    в который данные можно записать без фрагментации.
* xfs - предназначен для работы с большими файлами
* btrfs (B-tree filesystem)
* zfs (zetta filesystem)
* f2fs (flash friendly filesystem)
* squashfs - сжимающая файловая система
  
## Part 12. Использование утилиты du (disk usage)
```
du # выводит размер папок
du -sh /var/log # размер только этой папки
du -sh /var/log/* # размеры файлов в этой папке
du -h # размер файлов в человекочитаемом виде
du -h /home # размер содержимого директории
```
Описание иерархии каталогов согласно FHS
https://ru.wikipedia.org/wiki/FHS

* /etc
Общесистемные конфигурационные файлы (имя происходит от лат. et cetera).
* /home
Содержит домашние каталоги пользователей, которые в свою очередь содержат персональные настройки и данные пользователя.
Часто размещается на отдельном разделе.
* /proc
Виртуальная файловая система, представляющая состояние ядра операционной системы и запущенных процессов в виде файлов.
* /sys
Содержит информацию об устройствах, драйверах, а также некоторых свойствах ядра
* /usr
Вторичная иерархия для данных пользователя. Содержит большинство пользовательских приложений и утилит, используемых в многопользовательском режиме.
Может быть смонтирована по сети только для чтения и быть общей для нескольких машин.
* /var
Изменяемые файлы, такие как файлы регистрации, временные почтовые файлы, файлы спулеров.
* /var/cache
Кэш приложений. Такие данные генерируются локально в результате ресурсозатратных вычислений или операций ввода-вывода.
Приложение обязано уметь регенерировать эти данные. Данные файлы могут быть удалены без потери данных.
* /var/log
Различные файлы регистрации.

## Part 13. Установка и использование утилиты ncdu (NCurses Disk Usage)
>ncdu # отображает список файлов и директорий по объёму и позволяет тут же удалять ненужные файлы
ncdu /home # в конкретной директории

Перемещение по списку - кнопки со стрелками вверх и вниз
>Открытие папки - Enter
Удаление файла - кнопку d
Выход - q

## Part 14. Работа с системными журналами
выводим последние строки:
>tail /var/log/auth.log # выведет последние 10 строк
tail -n 20 /var/log/auth.log # выведет последние 20 строк
tail -f /var/log/auth.log # будет добавлять логи в режиме реального времени

Логи хранятся:
1. /var/log/dmesg
2. /var/log/syslog
3. /var/log/auth.log  

### Подсветка имени пользователя@сервера:
  в файле __~/.bashrc__ раскомментировать строку _force_color_prompt=yes_
  далее либо перезапустить
  либо __source .bashrc__
  
#### Виды логов в разных папках
* __/var/log/syslog или /var/log/messages__ содержит глобальный системный журнал, в котором пишутся сообщения с момента запуска системы, от ядра Linux,
различных служб, обнаруженных устройствах, сетевых интерфейсов и много другого.
* __/var/log/auth.log__ или __/var/log/secure__ — информация об авторизации пользователей, включая удачные и неудачные попытки входа в систему,
а также задействованные механизмы аутентификации.
* __/var/log/dmesg__ — драйвера устройств.

## Part 15. Использование планировщика заданий CRON
crontab -e # edit - изменить crontab
crontab -l # вывести содержимое crontab в терминал

__В crontab:__
```
* - каждую минуту/час/день месяца/месяц/день недели
*/2 - каждые 2
*/3 - каждые 3
```  

__в command можно писать:__
* команду
* bash-скрипт
* команда/bash-скрипт + перенаправление для сохранения/добавления в файл:
```
uptime > /home/yulia/logs/mylogs.log (пересохранить с новыми данными)
uptime >> /home/yulia/logs/mylogs.log (добавить к уже существующим данным)
```
__sudo nano /var/spool/cron/crontabs/yulia__ # в файле лежит файл, который открывается по команде crontab -e
__sudo nano /etc/crontab__ # в файле лежит crontab, в которую можно вносить задачи от имени root или другого пользователя
